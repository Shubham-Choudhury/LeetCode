// Link: https://leetcode.com/problems/minimize-malware-spread/

#include <iostream>
#include <vector>
#include <cstring>
#include <climits>
#include <queue>
#include <set>
#include <algorithm>
using namespace std;

class Solution
{
    int BFS(int x, vector<vector<int>> &graph, set<int> &st)
    {
        vector<int> visited(graph.size(), 0);
        int cnt = 0;
        queue<int> q;
        q.push(x);
        while (!q.empty())
        {
            int top = q.front();

            if (st.count(top) && top != x)
                return -1;
            q.pop();
            if (visited[top])
                continue;

            visited[top] = 1;
            cnt++;
            for (int j = 0; j < graph[0].size(); ++j)
            {

                if (graph[top][j] == 1 && visited[j] == 0)
                    q.push(j);
            }
        }
        return cnt;
    }

public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        set<int> st(initial.begin(), initial.end());
        int maxi = 0;
        int ret = -1;
        int ans = initial[0];
        for (int i = 0; i < initial.size(); ++i)
        {
            ret = BFS(initial[i], graph, st);

            if (ret > maxi)
            {
                maxi = ret;
                ans = initial[i];
            }
            else if (ret == maxi)
            {
                ans = min(ans, initial[i]);
            }
        }
        if (ret == -1)
        {
            return *min_element(initial.begin(), initial.end());
        }
        return ans;
    }
};

int main()
{
    Solution a;
    vector<vector<int>> graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
    vector<int> initial = {0, 1};
    cout << a.minMalwareSpread(graph, initial) << endl;
    return 0;
}
